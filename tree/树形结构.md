1. 树形结构有一个根结点
2. 树形结构没有回路
3. 树是图的一种，树的学名是有向无环图。

一些概念

1. 根结点
2. 叶子结点： 下面没有其他节点了 (E, F)
3. 节点： 既不是根结点又不是叶子结点 (D)
4. 树的度： 这棵树有最多叉的节点有多少个叉，这棵树的度就为多少。
   解： 有最多叉的节点是 A，那这棵树的度为 3
5. 树的深度： 树最深有几层，树的深度就为几。
---解： 树的深度最深为 3
<!--
     A
   / | \
   B C  D
       / \
      E   F
-->

二叉树：树的度最多为 2 的树形结构

<!--
    A
   / \
  C   B
     / \
    D   E
-->

1. 二叉树的根节点 A
2. 子节点：某个节点下的节点（比如 A 的子节点就是 B、C）
3. 父节点： 上级节点
4. 叶子结点： CDE
5. 节点： B

满二叉树：
需要满足下面两个条件：

1. 所有的叶子结点都在最底层
2. 每个非叶子节点都有两个子节点

完全二叉树：
国内定义：
（1）叶子节点都在最后一层或在倒数第二层
（2）叶子结点都向左聚拢。
国际定义：
（1）叶子结点都在最后一层或者倒数第二层
（2）如果有叶子结点，就必然有两个叶子结点。

子树： 二叉树中，每一个节点或者叶子结点，都是一颗子树的根节点。
在二叉树中，每个节点都认为自己是根节点，因为每个节点都知道自己的左孩子是谁，右孩子是谁。

<!--
     A
   /    \
  C      B
 / \    / \
D   E  F  G
-->

左子树 C 是 A 的左子树
右子树 B 是 A 的右子树

算法：
树怎么遍历：
传什么： 传递二叉树要传根节点
怎么遍历：三种遍历方式

1. 前序遍历： （先根次序遍历）
   先打印当前的，再打印左边的子树，在打印右边的子树
2. 中序遍历： （中根次序遍历）
   先打印左边的子树，在打印当前的，在打印右边的子树
3. 后序遍历： （后根次序遍历）
   先打印左边的子树，在打印右边的子树，在打印中间的

前中后是针对当前的

1. 求高度一定是用后序遍历
2. 求深度一定要用前序遍历
3. 路径问题- 回溯！
4. 回溯的代码精简之后再看看

求每个节点对应的深度
// 广度优先搜索
const queue = [[root, 1]]
while() {
//...
const [[node,l]] = queue.pop()
// l 就是当前节点的深度
}
